
# Загрузка нужных библиотек
library(readxl) # для чтения эксель файлов
library(dplyr) # для обработки данных
library(stringr) # для работы со строками
library(tidyr) #  для работы с данными 
library(ggplot2) # для работы с графиками 


# Создаем пустой датафрейм для хранения всех данных
all_data <- data.frame()

# Цикл по вкладкам с 2012 по 2022 год, чтобы собрать данные по годам из вкладок эксель в
# датафрейм удобный для работы.

for (year in 2012:2022) {
  # Читаем данные из вкладки, пропуская первые 4 строки
  sheet_data <- read_excel("Urov-14a_2010-2022.xlsx", 
                           sheet = as.character(year), skip = 4)
  
  # Удаляем пустые строки
  sheet_data <- sheet_data %>% filter(!is.na(`Код ОКТМО`))  
  
  # Добавляем столбец с годом
  sheet_data$year <- year
  
  # Добавляем данные из текущей вкладки в общий датафрейм
  all_data <- bind_rows(all_data, sheet_data)
}
# Удалим первые 2 колонки.
all_data <- all_data[, -c(1, 2)]  
head()

#  ШАГ 1. Предобработка данных

# Добавляем нули в "Код ОКТМО", где нужно
# Важное примечание: Код ОКТМО в данных по социальным выплатам и сбериндексу отличаются
# Код предпроцессинга данных для присоединения со сбериндексовм
all_data <- all_data %>%
  mutate(`Код ОКТМО` = case_when(
    # Для регионов 0-1 с пробелами
    substr(`Код ОКТМО`, 1, 1) %in% c("0", "1") & nchar(`Код ОКТМО`) == 9 ~ paste0("0", `Код ОКТМО`), 
    # Для региона 2 с пробелами, без добавления нуля
    substr(`Код ОКТМО`, 1, 1) %in% c("2") & nchar(`Код ОКТМО`) == 9 ~ sub("(\\d)(\\d{3})(\\d{3})", "\\1 \\2 \\3", `Код ОКТМО`),  
    # Для регионов 3-9 без пробелов 
    substr(`Код ОКТМО`, 1, 1) %in% c("3", "4", "5", "6", "7", "8", "9") & nchar(`Код ОКТМО`) == 7 ~ paste0("0", sub("(\\d)(\\d{3})(\\d{3})", "\\1 \\2 \\3", `Код ОКТМО`)), 
    # Для кодов, начинающихся с двузначного числа
    nchar(`Код ОКТМО`) == 8 ~ sub("(\\d{2})(\\d{3})(\\d{3})", "\\1 \\2 \\3", `Код ОКТМО`),  
    substr(`Код ОКТМО`, 1, 1) %in% c("1") & nchar(`Код ОКТМО`) == 7 & year %in% c(2019:2022) ~ paste0("0", sub("(\\d)(\\d{3})(\\d{3})", "\\1 \\2 \\3", `Код ОКТМО`)), # Для кодов, начинающихся с 1, без пробелов, в период 2019-2022 
    TRUE ~ `Код ОКТМО` # В остальных случаях оставляем без изменений
  ))


# Приводим "Код ОКТМО" к формату "oktmo" Добавляем тире и дополнительные 3 нуля на конце
all_data <- all_data %>%
  mutate(`Код ОКТМО` = str_replace_all(`Код ОКТМО`, " ", "-")) %>% 
  mutate(`Код ОКТМО` = paste0(`Код ОКТМО`, "-000"))

head(all_data,5) # посмотрим на первые 5 строчек
str(all_data) 


# ШАГ 2  ПРИСОЕДИНЕНИЕ к СБЕРИНДЕКСУ

# Теперь читаем данные из справочника
municipal_directory <- read_excel("t_dict_municipal_districts.xlsx")
# посмотрим структуру данных
str(municipal_directory)

# Фильтруем all_data, оставляя данные с 2018 года и позже
# создаем новый датафрейм all_data_filtered, 
# который содержит только строки из all_data, где год (year)  больше или равен 2018.
#Это нужно, потому что справочник municipal_directory  содержит данные только с 2018 года.
all_data_filtered <- all_data %>%
  filter(year >= 2018)

# удаляем дубликаты строк из all_data_filtered, оставляя только 
#уникальные комбинации кода ОКТМО (Код ОКТМО) и года (year). 
#Аргумент .keep_all = TRUE сохраняет все остальные столбцы в датасете. 
#Это нужно, чтобы избежать дубликатов при объединении данных с municipal_directory
all_data_filtered <- all_data_filtered %>%
  distinct(`Код ОКТМО`, year, .keep_all = TRUE) 
# Посмотрим данные
View(all_data_filtered)



# Выполняем left join между all_data_filtered и municipal_directory, 
final_data <- all_data_filtered %>% 
  # используя столбцы "Код ОКТМО" и "oktmo" как ключи для объединения. 
  # Left join сохраняет все строки из all_data_filtered и добавляет 
  # соответствующие столбцы из municipal_directory.
  left_join(municipal_directory, by = c("Код ОКТМО" = "oktmo")) %>% 
  
  # Группируем данные по "Код ОКТМО" и "year" для последующей фильтрации
  # внутри каждой группы.
  group_by(`Код ОКТМО`, year) %>% 
  
  # Фильтруем данные внутри каждой группы, оставляя только те строки,
  # где год из all_data_filtered ("year") попадает в период действия
  # записи из municipal_directory (от "year_from" до "year_to", 
  # не включая "year_to").  
  filter(year >= year_from & year < year_to) %>% # Изменено условие фильтрации
  
  # Отменяем группировку, сделанную ранее.
  ungroup()

# Просматриваем полученный датафрейм final_data.
View(final_data) 


# Здесь мы агрегируем данные по territory_id, year и Код ОКТМО,
#суммируя значения социальных выплат и налогооблагаемых доходов. .groups = "drop" 
#отменяет группировку после агрегации. 
#Этот шаг нужен, чтобы избежать дубликатов строк после left_join.
grouped_data <- final_data %>%
  group_by(territory_id, year, `Код ОКТМО`) %>%  # Добавили Код ОКТМО в group_by
  summarize(`Социальные и другие выплаты, тыс.рублей` = sum(`Социальные и другие выплаты, тыс.рублей`, na.rm = TRUE),
            `Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей` = sum(`Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей`, na.rm = TRUE), 
            .groups = "drop") 

# 
# Здесь мы создаем новый столбец actual_oktmo и присваиваем каждой территории 
# ее актуальный код ОКТМО, учитывая год. Если год больше или равен 2018,
# то используется последний код ОКТМО из группы (last(Код ОКТМО)). 
# Если год меньше 2018, то используется первый код ОКТМО из группы (first(Код ОКТМО)).
grouped_data <- grouped_data %>%
  group_by(territory_id) %>%
  mutate(actual_oktmo = ifelse(year >= 2018, last(`Код ОКТМО`), first(`Код ОКТМО`)))



# Здесь мы преобразуем grouped_data в "широкий" формат, где каждый 
# год представлен отдельным столбцом. pivot_wider создает новые столбцы для каждого года,
# используя значения из столбцов Социальные и другие выплаты, тыс.рублей и 
# Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей.
result_table <- grouped_data %>%
  select(actual_oktmo, year, `Социальные и другие выплаты, тыс.рублей`, 
         `Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей`) %>% 
  pivot_wider(names_from = year, values_from = c(`Социальные и другие выплаты, тыс.рублей`, 
                                                 `Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей`)) 

# посмотрим данные в таблице
View(result_table)

# Датафрейм result_table содержит информацию об объеме социальных выплат 
# и налогооблагаемых денежных доходах 
# для каждого муниципального образования (идентифицированного по territory_id 
# и actual_oktmo) за каждый год с 2018 по 2022.
# Мы учли изменения типов, названий и кодов муниципальных образований,
# используя справочник municipal_directory.Мы также учли изменения в территориальном 
# составе, объединяя данные с помощью left_join и фильтруя строки по year_from и year_to.

# ШАГ 3 Анализ изменения доли социальных выплат относительно 2018 года
Prop_change <- result_table %>%
  mutate(total_income_2018 = `Социальные и другие выплаты, тыс.рублей_2018` + `Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей_2018`,
         total_income_2022 = `Социальные и другие выплаты, тыс.рублей_2022` + `Налогооблагаемые денежные доходы физических лиц и индивидуальных предпринимателей, тыс.рублей_2022`,
         share_2018 = `Социальные и другие выплаты, тыс.рублей_2018` / total_income_2018,
         share_2022 = `Социальные и другие выплаты, тыс.рублей_2022` / total_income_2022,
         share_change = share_2022 - share_2018)

# просмотр табличных данных
View(Prop_change)


# Визуализация

# Гистограмма
ggplot(Prop_change, aes(x = share_change)) +
  geom_histogram(binwidth = 0.05, fill = "lightblue", color = "black") + 
  labs(title = "Распределение изменения доли социальных выплат (2022 vs 2018)",
       x = "Изменение доли", y = "Количество муниципальных образований") +
  theme_minimal()


# Диаграмма рассеяния "до-после"
ggplot(Prop_change, aes(x = share_2018, y = share_2022)) +
  geom_point(color = "blue", alpha = 0.7) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "red") +
  labs(title = "Доля социальных выплат в 2018 vs 2022", 
       x = "Доля в 2018", y = "Доля в 2022") +
  theme_minimal()

# посмотрим коэффициент корреляции 
cor(Prop_change$share_2018, Prop_change$share_2022, use = "complete.obs")
#[1] 0.8347956 . Очень сильная положительная зависимость

